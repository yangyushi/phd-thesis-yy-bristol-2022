\documentclass[11pt,twoside]{report}
\usepackage{preamble}
\graphicspath{{../img/ch8/}}
\setcounter{chapter}{8}
\renewcommand{\chaptername}{Appendix}
\renewcommand{\thechapter}{\Alph{chapter}}

\begin{document}

\chapter{Practical Coding}
\label{chapter:algorithms}

\epigraph{Talk is cheap, show me the code.}{Linus Torvalds, 2000}

\section{Introduction}

This chapter is dedicated to enthusiastic programmers. However fancy the equations and arguments might be, at the end of the day, most of these ideas need to be translated into binary instructions that can be mercilessly executed by computers, whose hearts beat at the frequency of gigahertz in the 2020s. The art of translating human idea into binary language, \emph{programming}, can only be carried out by the people. This task can be very difficult, and this chapter will hopefully makes it easier for the readers to implement the ideas sparkled around in this thesis.

In the first section, the overview of current landscape of programming will be introduced, with special focus on what language to use in different situations. In the second section I will talk about my way to organise the code, which can be crucial when the size of the programming project exceeds 10,000 lines of code. In the last section I will write down some helpful algorithms for data analysis and simulation.

\section{Programming in the 2020s}

\section{Effective Way to Organise the Code}


To the best of my knowledge, there is no framework nor libraries\marginfootnote{The term ``library'' refers to a collection of reusable code, which can be called by the user. The term ``framework'' refers to a collection of libraries and other utilities, which functions with the input of the user. The example of a library is ``Numpy'', which provides efficient n--dimensional array operations. The example of a framework is the Large-scale Atomic/Molecular Massively Parallel Simulator (LAMMPS), which read the user input file and perform molecular dynamic simulations.}
for the reconstruction of 3D trajectories from synchronised multiple--view videos at the time of this research (from 2018 to 2022). Therefore, I have to write all the analysing code from scratch, which turned out to be a real challenge in terms of software engineering. Developing the software is difficult because the 3D reconstruction process are composed of many small tasks, for instance the 2D feature selection and the camera calibration. New features and algorithms were frequently added to cope with different tasks, which would inevitably increase the complexity of the framework/library. If not being careful with the complexity, the code may eventually end up being not maintainable, forbidding its further improvement.

The way I organised my framework is summarised by the tree below. Each node represent either a directory (with capitalised first letter) or a file (with lower case letters). For instance, \code{Executable} is a folder and \code{exec_task_1} is a file.



\begin{tcolorbox}[
title=Project Structure of My Framework,
enlarge bottom by=0.5em,
enlarge top by=0.5em,
]

\begin{diagram}
	\dirtree{%
	.1 Framework.
	.2 Executable\marginfootnote{\textrm{It is convenient to add the \texttt{Executable} directory to the \texttt{PATH} environment variable, so that we can call these executable files directly.}} (Called by the user).
	.3 exec\_task\_1.
	.3 exec\_task\_2.
	.2 Script (Calls the library).
	.3 Task\_1.
	.4 scirpt.py.
	.4 config.ini (user input).
	.3 Task\_2.
	.2 Library\marginfootnote{\textrm{I used Python as the main script language. In my case, it is very convenient to add the \texttt{Library} directory to the \texttt{PYTHONPATH} environment variable, so that one can directly import the modules.}}.
	.3 Module\_1.
	.4 foobar.py.
	.4 hoge.so.
	.4 tutu.a.
	.3 Module\_2.
}
\end{diagram}

\end{tcolorbox}

The users interact with the framework only through the executables. The user is expected to run the executable from a working directory (\code{PWD}). The executables would copy a task folder (\code{Framework/Script/Task_1}) to \code{PWD/Task_1}. The user input would handled by changing the configuration file (\code{config.ini}), and the results would be obtained by executing the script (\code{script.py}). The generated result will be kept inside the copied task folder (\code{PWD/Task_1}). The task folders can be ``volatile'', and suffer from frequent changes and errors. This volatility is acceptable, since each task is a self--contained unit, as the script and configuration file uniquely determines the obtained result.

All of the implemented algorithms (subroutines, functions, classes) were placed inside the library (\code{Framework/Library}), and they are called by the scripts. These algorithms need much more attention than the scripts, and they ideally require careful tests. If a function in the algorithm provides a wrong answer, then all the scripts calling this function needed to be re-calculated, affecting potentially many tasks. In addition, the different modules should not depend on each other\marginfootnote{In terms of Python, it means the \texttt{*.py} files in \texttt{Module\_1} would not import from other modules, and vice versa.}, in order to reduce the complexity of the library.

With such structure, it is easy and clear to add new functions for new tasks. For instance, if I want to perform a new task (\code{T}) with a new algorithms (\code{A}), I will create the collection of script, for task \code{T}, under the folder \code{Framework/Script}. Also, I would implement algorithm \code{A} inside a module, then write an executable file for the user. The following tree diagram represented the updated framework.

\begin{tcolorbox}[
title=Project Structure of My Framework,
enlarge bottom by=0.5em,
enlarge top by=0.5em,
]

\begin{diagram}
	\dirtree{%
	.1 Framework.
	.2 Executable (Called by the user).
	.3 exec\_task\_1.
	.3 exec\_task\_2.
	.3 \color{teal}{exec\_T}.
	.2 Script (Calls the library).
	.3 Task\_1.
	.3 Task\_2.
	.3 \color{teal}{New\_Task\_T}.
	.2 Library.
	.3 Module\_1.
	.4 foobar.py \color{teal}{(+ code for algorithm A)}.
	.4 hoge.so.
	.4 tutu.a.
	.3 Module\_2.
}
\end{diagram}

\end{tcolorbox}

\noindent With this clear framework structure and version control softwares (\code{git} and GitHub), I managed to maintain the fish tracking code through out the 4--year project, working seamlessly on both my personal laptop and HPC clusters.


\section{Some Useful Algorithms}


The algorithm to rotate one 3D vector to the direction of another 3D vector is introduced in the following algorithm. This rotation is important to generate the scalar noise in the Vicsek model and the Couzin model.

\begin{tcolorbox}[
title=Algorithm to Rotate a 3D vector,
enlarge bottom by=0.5em,
enlarge top by=0.5em,
]

\label{alg:geometry-rotate}
\begin{algorithmic}

\Procedure{rotate-vector}{$\mathbf{v}_1 \in \mathbb{R}^3 $, $\mathbf{v}_2 \in \mathbb{R}^3 $} \marginfootnote{The term ``$\mathbf{v}_1 \in \mathbb{R}^3$'' indicates the shape of the array \texttt{v1}. Using the \texttt{numpy} library, we should expect the output of \texttt{v1.shape} to be \texttt{(3,)}.}
\State $\mathbf{u} \in \mathbb{R}^3 \gets$ vector project of $\mathbf{v}_2$ on $\mathbf{v}_1$ 
\State $\mathbf{v} \in \mathbb{R}^3 \gets \mathbf{v}_2 - \mathbf{u}$  \Comment{vector rejection of $\mathbf{v}_2$ on $\mathbf{v}_1$}
\State $\mathbf{w} \in \mathbb{R}^3 \gets \mathbf{u} \times \mathbf{v}$
\State $\theta \gets 
\arccos( \frac{\mathbf{v}_1 \cdot \mathbf{v}_2} { |\mathbf{v}_1| |\mathbf{v}_2|})
$ \Comment{The angle between $\mathbf{v}_2$ and $\mathbf{v}_1$ }
\State $\mathbf{u} \gets \mathbf{u} / |\mathbf{u}|$
\State $\mathbf{v} \gets \mathbf{v} / |\mathbf{v}|$ \\
\State $\mathbf{F} \in \mathbb{R}^{3 \times 3} \gets
(\mathbf{u}^T; \mathbf{v}^T; \mathbf{w}^T)
$ \Comment{New orthogonal basis} \\
\State $
\mathbf{G} \gets \left(
\begin{matrix}
	\cos \theta & -\sin \theta & 0 \\
	\sin \theta & -\cos \theta & 0 \\
	0 & 0 & 1
\end{matrix}
\right)
$\\
\State $\mathbf{R} \in \mathbb{R}^{3 \times 3} \gets
\mathbf{F}^{-1} \cdot \mathbf{G} \cdot \mathbf{F}
$
\State \textbf{return} $\mathbf{R}$
\EndProcedure
\end{algorithmic}

\end{tcolorbox}




The following algorithm will generate random 3D points distributed uniformly on a spherical cap. This algorithm will be used when randomly rotating the orientations of agents in the Vicsek model and Couzin model.



\begin{tcolorbox}[
title=Algorithm to Generate Uniform Points on a Spherical Cap,
enlarge bottom by=0.5em,
enlarge top by=0.5em,
]

\label{alg:geometry-rand-cap}
\begin{algorithmic}

\Procedure{rand-vector-on-cap}{}

\State \textbf{return} $\mathbf{p}$
\EndProcedure
\end{algorithmic}

\end{tcolorbox}



The following algorithm will calculate the path of the light travelling into water. During such process, the air--water interface will cause the direction of the light beam to change. Correctly calculating the effect of refraction is an elemental part in the 3D tracking of the fish.



\begin{tcolorbox}[
title=Algorithm to Calculate the Direction of Light after Refraction,
enlarge bottom by=0.5em,
enlarge top by=0.5em,
]

\label{alg:geometry-rand-cap}
\begin{algorithmic}

\Procedure{refractive-direction}{$\mathbf{u} \in \mathbb{R}^3$, $z \in \mathbb{R}$}

\State \textbf{return} $\mathbf{p}$
\EndProcedure
\end{algorithmic}

\end{tcolorbox}

The following algorihm offered a direct way to sample points distributed uniformly inside a fish tank, whose goemtry is described by $z = c r^2$. This direct sample method is useful for generating initial positions of agents inside the tank, at the beginning of the simulation.

\begin{tcolorbox}[
title=Algorithm to Sample Uniform Points in Fish Tank,
enlarge bottom by=0.5em,
enlarge top by=0.5em,
]

\label{alg:geometry-rand-cap}
\begin{algorithmic}
\Procedure{sample-direct-fish-tank}{c, h}

\State $Z \gets$ rand(0, 1)
\State $R \gets $ rand(0, 1)
\State $\theta \gets $ rand($-\pi$, $\pi$)

\State $z \gets h \sqrt{Z}$ 
\State $r \gets \sqrt{R} \sqrt{z / c}$

\State $x \gets r \cos(\theta)$
\State $y \gets r \sin(\theta)$

\State \textbf{return} $(x, y, z)$

\EndProcedure
\end{algorithmic}
\end{tcolorbox}


\section{Useful Machine Learning Ideas}

Machine learning is a vivid and useful technique, especially its deep learning branch. In this section I will gave a quick introduction to two methods that are frequently utilised in the thesis. The principle component analysis (PCA) and the deep neural network (DNN).

The PCA is a tool to get a rotational matrix for N-dimensional point cloud.

\end{document}
